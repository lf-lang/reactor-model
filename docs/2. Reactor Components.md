# Reactor Components

*This is a WIP.*

* Mention the approach of description-finite-toFinset.
* Mention naming conventions.

---

While the previous document on the [Formalization Structure](1. Formalization Structure.md)
explains how and why the components of the Reactor model are formalized in a certain way,
it generally ignores the nature of the components themselves.
In this document we intend to do the opposite: We take a look at each of the components of
the Reactor model in detail, while generally ignoring the technicalities of the larger 
formalization structure. There are three components to consider: `Change`, `Reaction` and `Reactor`.

## `Change`

> *While this section focuses mainly on `Change`, we will also introduce raw lifting and raw*
> *equivalence here, which are concepts relevant for all components.*

In the semi-formal definition of the Reactor model, reactions' bodies are defined as "opaque code" that
has access to a set of APIs for settings ports' values, connecting ports, creating reactors, etc.
The definition of a reaction's body used in *this* formalization is as a function of type
`Ports ι υ → StateVars ι υ → List (Change ι υ)` (as we will see in the section on `Reaction`s).
That is, we ignore all side effects that a reaction could have and only consider the part that is
relevant to the reactor system: the API calls. These API calls are formalized by the `Change` type:

```lean
-- Components/Change.lean

inductive Change (ι υ) [ID ι] [Value υ]
  | port (target : ι) (value : υ)
  | state (target : ι) (value : υ)
  | connect (src : ι) (dst : ι)
  | disconnect (src : ι) (dst : ι)
  | create (rtr : Reactor ι υ) (id : ι)
  | delete (rtrID : ι)
```

Thus, if a reaction were to call the API for setting a port's value, we would formalize this as returning
an instance `Change.port <target> <value>`. Since a reaction can perform multiple API calls per execution,
it returns a `List` of `Change`s.

Instances of `Change` can be split into two groups: those which express a mutation to the structure of a
reactor system, and those which don't:

```lean
def Change.mutates : Change ι υ → Bool 
  | port _ _       => false
  | state _ _      => false
  | connect _ _    => true
  | disconnect _ _ => true
  | create _ _     => true
  | delete _       => true
```

This distinction will be used later to differentiate between "normal" reactions and mutations, as normal
reactions are not allowed to produce mutating changes.
The actual behavior that should result from applying a `Change` will be part of the definition of reactor
execution.

### Raw Lifting

Before we move on, we need to consider one detail of the `create` constructor.
While `Raw.Change` takes a `Raw.Reactor` as parameter for its `create` constructor, we now take a "proper"
`Reactor`. This detail will become relevant when transforming `Raw.Reaction`s to "proper" `Reaction`s
(in the section on `Reaction`s), because it will require us to turn `Raw.Change`s into "proper" `Change`s.
For this purpose we define a `Change.fromRaw` function:

```lean
def fromRaw
  {rtr : Raw.Reactor ι υ} (hw : rtr.wellFormed) 
  {rcn : Raw.Reaction ι υ} (hr : ∃ i, rtr.rcns i = rcn) 
  {c : Raw.Change ι υ} {p s} (hc : c ∈ Raw.Reaction.body rcn p s) : 
  Change ι υ :=
    match hm:c with 
    | Raw.Change.port target value  => Change.port target value  
    | Raw.Change.state target value => Change.state target value 
    | Raw.Change.connect src dst    => Change.connect src dst    
    | Raw.Change.disconnect src dst => Change.disconnect src dst 
    | Raw.Change.delete rtrID       => Change.delete rtrID
    | Raw.Change.create cr id => 
      Change.create { 
        raw := cr, 
        wf := by 
          rw [hm] at hc
          have ha := Raw.Reactor.isAncestorOf.creatable hr.choose_spec hc
          exact Raw.Reactor.isAncestorOf_preserves_wf ha hw
      } id
```

Turning a `Raw.Change` into a `Change` is trivial for all constructors except the `create` constructor, where we
need to turn a `Raw.Reactor` into a `Reactor`. This is only possible if the raw reactor is well-formed, which is 
why the `Change.fromRaw` function requires a host of preconditions which allow us to prove this fact.

#### Raw Equivalence

In the following sections, we will come across more functions like `Change.fromRaw`, where we perform lifting of
raw components. To ensure that we perform this lifting properly, we prove that the lifted component is in fact
"equivalent" to the raw component from which it was lifted.
The precise definition of equivalence is different for each component, but it generally comes down to showing that
the "proper" and the raw instances contain the same data. Since our definitions of "proper" components are generally
the same as the raw components, just with additional proofs added on top, this comparison of "same data" is very direct.

The relation that expresses equivalence between a `Change` and a `Raw.Change` looks as follows:

```lean
inductive rawEquiv (c : Change ι υ) (raw : Raw.Change ι υ) : Prop
  | port       {t v} :    (c = Change.port t v)       → (raw = Raw.Change.port t v)                         → rawEquiv c raw
  | state      {t v} :    (c = Change.state t v)      → (raw = Raw.Change.state t v)                        → rawEquiv c raw
  | connect    {s d} :    (c = Change.connect s d)    → (raw = Raw.Change.connect s d)                      → rawEquiv c raw
  | disconnect {s d} :    (c = Change.disconnect s d) → (raw = Raw.Change.disconnect s d)                   → rawEquiv c raw
  | create     {r r' i} : (c = Change.create r i)     → (raw = Raw.Change.create r' i)    → (r.rawEquiv r') → rawEquiv c raw
  | delete     {i}   :    (c = Change.delete i)       → (raw = Raw.Change.delete i)                         → rawEquiv c raw
```

The `rawEquiv` for changes only holds when both changes are built from "the same" constructor with the same data.
Again, the `create` constructor is special in that "proper" constructor takes a `Reactor`, while the raw constructor takes a
`Raw.Reactor`. In this case we also need to require that those reactors are raw-equivalent. Luckily, raw-equivalence for
reactors is trivial:

```lean
def Reactor.rawEquiv (rtr : Reactor ι υ) (raw : Raw.Reactor ι υ) : Prop :=
  rtr.raw = raw
```

## `Reaction` (and Mutations)

## `Reactor`

