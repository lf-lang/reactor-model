# Reactor Components

*This is a WIP.*

* Mention the approach of description-finite-toFinset.
* Mention naming conventions.

---

While the previous document on the [Formalization Structure](1.%20Formalization%20Structure.md)
explains how and why the components of the Reactor model are formalized in a certain way,
it generally ignores the nature of the components themselves.
In this document we intend to do the opposite: We take a look at each of the components of
the Reactor model in detail, while generally ignoring the technicalities of the larger 
formalization structure. There are three components to consider: `Change`, `Reaction` and `Reactor`.

## `Change`

In the semi-formal definition of the Reactor model, reactions' bodies are defined as "opaque code" that
has access to a set of APIs for settings ports' values, connecting ports, creating reactors, etc.
The definition of a reaction's body used in *this* formalization is as a function of type
`Ports ι υ → StateVars ι υ → List (Change ι υ)` (as we will see in [`Reaction` (and Mutations)](#reaction-and-mutations)).
That is, we ignore all side effects that a reaction could have and only consider the part that is
relevant to the reactor system: the API calls. These API calls are formalized by the `Change` type:

```lean
-- Components/Change.lean

inductive Change (ι υ) [ID ι] [Value υ]
  | port (target : ι) (value : υ)
  | state (target : ι) (value : υ)
  | connect (src : ι) (dst : ι)
  | disconnect (src : ι) (dst : ι)
  | create (rtr : Reactor ι υ) (id : ι)
  | delete (rtrID : ι)
```

Thus, if a reaction were to call the API for setting a port's value, we would formalize this as returning
an instance `Change.port <target> <value>`. Since a reaction can perform multiple API calls per execution,
it returns a `List` of `Change`s.

Instances of `Change` can be split into two groups: those which express a mutation to the structure of a
reactor system, and those which don't:

```lean
def Change.mutates : Change ι υ → Bool 
  | port _ _       => false
  | state _ _      => false
  | connect _ _    => true
  | disconnect _ _ => true
  | create _ _     => true
  | delete _       => true
```

This distinction will be used later to differentiate between "normal" reactions and mutations, as normal
reactions are not allowed to produce mutating changes.
The actual behavior that should result from applying a `Change` will be part of the execution model of reactors.

## `Reaction` (and Mutations)

The components that can produce changes in a reactor system are reactions:

```lean
-- Components/Reaction.lean

structure Reaction (ι υ) [ID ι] [Value υ] where
  deps :        Ports.Role → Finset ι 
  triggers :    Finset ι
  children :    Finset ι
  body :        Ports ι υ → StateVars ι υ → List (Change ι υ)
  tsSubInDeps : triggers ⊆ deps Role.in
  outDepOnly :  ∀ p s {o} (v : υ), (o ∉ deps Role.out) → (Change.port o v) ∉ (body p s)
  normNoChild : (∀ i s c, c ∈ (body i s) → ¬c.mutates) → children = ∅
```

Reactions can have dependencies and antidependencies on ports. 
The `deps` field defines both kinds of dependencies by referring to the ports' identifiers and separating
these identifiers by the "role" of the port they refer to.
A `Ports.Role` is simply a utility type used for exactly these kinds of separations:

```lean
-- Primitives.lean

inductive Ports.Role 
  | «in» 
  | out
```

A reaction declares a set of `triggers`, which are a subset of its input ports.
The subset-property is enforced by `tsSubInDeps`.

Thus, we can define properties like `triggersOn` which defines when a given port assignment triggers
a reaction:

```lean
def Reaction.triggersOn (rcn : Reaction ι υ) (p : Ports ι υ) : Prop :=
  ∃ t, t ∈ rcn.triggers ∧ p[t] ≠ none
```

> The notation `p[t]` is `Ports.get` defined in `Primitives.lean`.
> You can think of it as lookup for a port value given a port ID.

### Reaction Body

A reaction's `body` is the function that describes its behavior in terms of the `Change`s it produces.
The inputs to the function are port values (`Ports ι υ`) and values for state variables
(`StateVars ι υ`). In the context of an execution of a reactor, the arguments to a reaction's `body`
will be input ports and state variables of the reactor that contains the reaction. The definition of
execution will ensure that we only pass in those input ports which are dependencies of the reaction (by
using `Finmap.restrict`).

> Note:
> We could have also defined a reaction's body in such a way that it accepts as inputs only
> precisely those ports (their values) which are declared in its dependencies.
> This is more cumbersome to work with at the call site though.

To ensure that a reaction's body only produces valid changes, we need to enforce some constraints:

* `outDepOnly`: The reaction can only write to ports that are in its antidependencies.
* TODO: Can constraints on `Change.{state, connect, disconnect, create, delete}` be moved from the
        execution model to here? I.e. which ones can LF figure out statically?

To make calling a reaction's body more convenient, we add a coercion that allows us to use call syntax
on the reaction itself:

```lean
instance : CoeFun (Reaction ι υ) (λ _ => Ports ι υ → StateVars ι υ → (List (Change ι υ))) where
  coe rcn := rcn.body
```

So when you see something like `rcn p s` that's the same as `rcn.body p s`.

### Mutations

In the section on `Changes` we defined a property that told us whether a change is mutating or not
(`Change.mutates`). We need this information in order to distinguish "normal" reactions from mutations.

We say that a reaction is "normal" if it produces no mutating changes:

```lean
def Reaction.isNorm (rcn : Reaction ι υ) : Prop :=
  ∀ i s c, c ∈ (rcn i s) → ¬c.mutates
```

We then say that a reaction is a mutation if it is not "normal":

```lean
def Reaction.isMut (rcn : Reaction ι υ) : Prop := ¬rcn.isNorm
```

Thus, `Reaction` is the type of "normal" reactions *and* mutations.
Whenever we want to talk about only one of these flavors, we require `isNorm` or `isMut` on the reaction.

One example of this is within the very definition of `Reaction`, to constrain the `children` field.
Children are a concept that only applies to mutations.
When mutations produce a `Change.create <reactor> <id>`, they need to remember the ID of the reactor they
created (for reasons that are related to the execution model). These IDs are recorded in their `children`
field. Since "normal" reactions can't create reactors (since this is a mutating change), they can't have
children. This is enforced by:

```lean
normNoChild : (∀ i s c, c ∈ (body i s) → ¬c.mutates) → children = ∅
```

The condition `∀ i s c, c ∈ (body i s) → ¬c.mutates` is precisely the definition of `Reaction.isNorm` (we
couldn't use `isNorm` in the definition of `Reaction` yet, as this would be circular).

### Relay Reactions

Relay reactions are a specific kind of reaction that allow us to simplify what it means for reactors' ports to be connected.
In the semi-formal definition of the Reactor model we say that reactors can contain nested reactors where the output ports of
a nested reactor can have a "connection" to an input port of another nested reactor.

This explicit notion of a "connection" can be removed by exploiting the way in which reactions can interact with nested reactors:
A reaction can declare as dependency an input port of its container or *an output port of a nested reactor* of its container.
Analogously, a reaction can declare as antidependency an output port of its container or *an input port of a nested reactor* of its container.
Thus, we can formalize connections between reactors' ports by creating a reaction that declares these ports and only these ports as dependency
and antidependency respectively, and does nothing but relay the value from its input to its output.

Therefore, we call such a reaction a relay reaction:

```lean
def Reaction.relay (src dst : ι) : Reaction ι υ := {
  deps := λ r => match r with | Role.in => Finset.singleton src | Role.out => Finset.singleton dst,
  triggers := Finset.singleton src,
  children := ∅,
  body := λ p _ => match p[src] with | none => [] | some v => [Change.port dst v],
  tsSubInDeps := ...,
  outDepOnly := ...,
  normNoChild := ...
}
```

In order to behave exactly as desired, relay reactions also require some special treatment within reactors.

## `Reactor`

The way in which we define `Reactor` is fundamentally different from `Change` and `Reaction`.
In the document on the [Formalization Structure](1.%20Formalization%20Structure.md) we determined that one of the
components in the mutually inductive cycle can't be sealed off from `Raw`-land by plain redefinition (as we did
with `Change` and `Reaction`), but instead has to use "API-tricks" to appear "proper". This burden falls on `Reactor`.