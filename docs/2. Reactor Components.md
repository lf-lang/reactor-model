# Reactor Components

*This is a WIP.*

* Mention the approach of description-finite-toFinset.
* Mention naming conventions.

---

While the previous document on the [Formalization Structure](1. Formalization Structure.md)
explains how and why the components of the Reactor model are formalized in a certain way,
it generally ignores the nature of the components themselves.
In this document we intend to do the opposite: We take a look at each of the components of
the Reactor model in detail, while generally ignoring the technicalities of the larger 
formalization structure. There are three components to consider: `Change`, `Reaction` and `Reactor`.

## `Change`

> *While this section focuses mainly on `Change`, we will also introduce raw lifting and raw*
> *equivalence here, which are concepts relevant for all components.*

In the semi-formal definition of the Reactor model, reactions' bodies are defined as "opaque code" that
has access to a set of APIs for settings ports' values, connecting ports, creating reactors, etc.
The definition of a reaction's body used in *this* formalization is as a function of type
`Ports ι υ → StateVars ι υ → List (Change ι υ)` (as we will see in [`Reaction`](#reaction)).
That is, we ignore all side effects that a reaction could have and only consider the part that is
relevant to the reactor system: the API calls. These API calls are formalized by the `Change` type:

```lean
-- Components/Change.lean

inductive Change (ι υ) [ID ι] [Value υ]
  | port (target : ι) (value : υ)
  | state (target : ι) (value : υ)
  | connect (src : ι) (dst : ι)
  | disconnect (src : ι) (dst : ι)
  | create (rtr : Reactor ι υ) (id : ι)
  | delete (rtrID : ι)
```

Thus, if a reaction were to call the API for setting a port's value, we would formalize this as returning
an instance `Change.port <target> <value>`. Since a reaction can perform multiple API calls per execution,
it returns a `List` of `Change`s.

Instances of `Change` can be split into two groups: those which express a mutation to the structure of a
reactor system, and those which don't:

```lean
def Change.mutates : Change ι υ → Bool 
  | port _ _       => false
  | state _ _      => false
  | connect _ _    => true
  | disconnect _ _ => true
  | create _ _     => true
  | delete _       => true
```

This distinction will be used later to differentiate between "normal" reactions and mutations, as normal
reactions are not allowed to produce mutating changes.
The actual behavior that should result from applying a `Change` will be part of the definition of reactor
execution.

### Raw Lifting

Before we move on, we need to consider one detail of the `create` constructor.
While `Raw.Change` takes a `Raw.Reactor` as parameter for its `create` constructor, we now take a "proper"
`Reactor`. This detail will become relevant when transforming `Raw.Reaction`s to "proper" `Reaction`s
(in the section on `Reaction`s), because it will require us to turn `Raw.Change`s into "proper" `Change`s.
For this purpose we define a `Change.fromRaw` function:

```lean
def Change.fromRaw
  {rtr : Raw.Reactor ι υ} (hw : rtr.wellFormed) 
  {rcn : Raw.Reaction ι υ} (hr : ∃ i, rtr.rcns i = rcn) 
  {c : Raw.Change ι υ} {p s} (hc : c ∈ Raw.Reaction.body rcn p s) : 
  Change ι υ :=
    match hm:c with 
    | Raw.Change.port target value  => Change.port target value  
    | Raw.Change.state target value => Change.state target value 
    | Raw.Change.connect src dst    => Change.connect src dst    
    | Raw.Change.disconnect src dst => Change.disconnect src dst 
    | Raw.Change.delete rtrID       => Change.delete rtrID
    | Raw.Change.create cr id => 
      Change.create { 
        raw := cr, 
        wf := by 
          rw [hm] at hc
          have ha := Raw.Reactor.isAncestorOf.creatable hr.choose_spec hc
          exact Raw.Reactor.isAncestorOf_preserves_wf ha hw
      } id
```

Turning a `Raw.Change` into a `Change` is trivial for all constructors except the `create` constructor, where we
need to turn a `Raw.Reactor` into a `Reactor`. This is only possible if the raw reactor is well-formed, which is 
why the `Change.fromRaw` function requires a host of preconditions which allow us to prove this fact.

### Raw Equivalence

In the following sections, we will come across more functions like `Change.fromRaw`, where we perform lifting of
raw components. To ensure that we perform this lifting properly, we prove that the lifted component is in fact
"equivalent" to the raw component from which it was lifted.
The precise definition of equivalence is different for each component, but it generally comes down to showing that
the "proper" and the raw instances contain the same data. Since our definitions of "proper" components are generally
the same as the raw components, just with additional proofs added on top, this comparison of "same data" is very direct.

The relation that expresses equivalence between a `Change` and a `Raw.Change` looks as follows:

```lean
inductive Change.rawEquiv (c : Change ι υ) (raw : Raw.Change ι υ) : Prop
  | port       {t v} :    (c = Change.port t v)       → (raw = Raw.Change.port t v)                         → rawEquiv c raw
  | state      {t v} :    (c = Change.state t v)      → (raw = Raw.Change.state t v)                        → rawEquiv c raw
  | connect    {s d} :    (c = Change.connect s d)    → (raw = Raw.Change.connect s d)                      → rawEquiv c raw
  | disconnect {s d} :    (c = Change.disconnect s d) → (raw = Raw.Change.disconnect s d)                   → rawEquiv c raw
  | create     {r r' i} : (c = Change.create r i)     → (raw = Raw.Change.create r' i)    → (r.rawEquiv r') → rawEquiv c raw
  | delete     {i}   :    (c = Change.delete i)       → (raw = Raw.Change.delete i)                         → rawEquiv c raw
```

The `rawEquiv` relation for changes only holds when both changes are built from "the same" constructor with the same data.
The `create` constructor is special again in that the "proper" constructor takes a `Reactor`, while the raw constructor takes a
`Raw.Reactor`. In this case we also need to require that those reactors are raw-equivalent. Luckily, raw-equivalence for
reactors is trivial:

```lean
def Reactor.rawEquiv (rtr : Reactor ι υ) (raw : Raw.Reactor ι υ) : Prop :=
  rtr.raw = raw
```

## `Reaction` (and Mutations)

The components that can produce changes in a reactor system are reactions:

```lean
-- Components/Reaction.lean

structure Reaction (ι υ) [ID ι] [Value υ] where
  deps :        Ports.Role → Finset ι 
  triggers :    Finset ι
  children :    Finset ι
  body :        Ports ι υ → StateVars ι υ → List (Change ι υ)
  tsSubInDeps : triggers ⊆ deps Role.in
  outDepOnly :  ∀ p s {o} (v : υ), (o ∉ deps Role.out) → (Change.port o v) ∉ (body p s)
  normNoChild : (∀ i s c, c ∈ (body i s) → ¬c.mutates) → children = ∅
```

Reactions can have dependencies and antidependencies on ports. 
The `deps` field defines both kinds of dependencies by referring to the ports' identifiers and separating
these identifiers by the "role" of the port they refer to.
A `Ports.Role` is simply a utility type used for exactly these kinds of separations:

```lean
-- Primitives.lean

inductive Ports.Role 
  | «in» 
  | out
```

A reaction declares a set of `triggers`, which are a subset of its input ports.
The subset-property is enforced by `tsSubInDeps`.

Thus, we can define properties like `triggersOn` which defines when a given port assignment triggers
a reaction:

```lean
def Reaction.triggersOn (rcn : Reaction ι υ) (p : Ports ι υ) : Prop :=
  ∃ t, t ∈ rcn.triggers ∧ p[t] ≠ none
```

> The notation `p[t]` is `Ports.get` defined in `Primitives.lean`.
> You can think of it as lookup for a port value given a port ID.

### Reaction Body

A reaction's `body` is the function that describes its behavior in terms of the `Change`s it produces.
The inputs to the function are port values (`Ports ι υ`) and values for state variables
(`StateVars ι υ`). In the context of an execution of a reactor, the arguments to a reaction's `body`
will be input ports and state variables of the reactor that contains the reaction. The definition of
execution will ensure that we only pass in those input ports which are dependencies of the reaction (by
using `Finmap.restrict`).

> Note:
> We could have also defined a reaction's body in such a way that it accepts as inputs only
> precisely those ports (their values) which are declared in its dependencies.
> This is more cumbersome to work with at the call site though.

To ensure that a reaction's body only produces valid changes, we need to enforce some constraints:

* `outDepOnly`: The reaction can only write to ports that are in its antidependencies.
* TODO: Can constraints on `Change.{state, connect, disconnect, create, delete}` be moved from the
        execution model to here? I.e. which ones can LF figure out statically?

To make calling a reaction's body more convenient, we add a coercion that allows us to use call syntax
on the reaction itself:

```lean
instance : CoeFun (Reaction ι υ) (λ _ => Ports ι υ → StateVars ι υ → (List (Change ι υ))) where
  coe rcn := rcn.body
```

So when you see something like `rcn p s` that's the same as `rcn.body p s`.

### Mutations

In the section on `Changes` we defined a property that told us whether a change is mutating or not
(`Change.mutates`). We need this information in order to distinguish "normal" reactions from mutations.

We say that a reaction is "normal" if it produces no mutating changes:

```lean
def Reaction.isNorm (rcn : Reaction ι υ) : Prop :=
  ∀ i s c, c ∈ (rcn i s) → ¬c.mutates
```

We then say that a reaction is a mutation if it is not "normal":

```lean
def Reaction.isMut (rcn : Reaction ι υ) : Prop := ¬rcn.isNorm
```

Thus, `Reaction` is the type of "normal" reactions *and* mutations.
Whenever we want to talk about only one of these flavors, we require `isNorm` or `isMut` on the reaction.

One example of this is within the very definition of `Reaction`, to constrain the `children` field.
Children are a concept that only applies to mutations.
When mutations produce a `Change.create <reactor> <id>`, they need to remember the ID of the reactor they
created (for reasons that are related to the execution model). These IDs are recorded in their `children`
field. Since "normal" reactions can't create reactors (since this is a mutating change), they can't have
children. This is enforced by:

```lean
normNoChild : (∀ i s c, c ∈ (body i s) → ¬c.mutates) → children = ∅
```

The condition `∀ i s c, c ∈ (body i s) → ¬c.mutates` is precisely the definition of `Reaction.isNorm` (we
couldn't use `isNorm` in the definition of `Reaction` yet, as this would be circular).

### Raw Lifting and Equivalence

Lifting of `Raw.Reaction`s to `Reaction`s is performed in `Reaction.fromRaw`.
The main steps for lifting are converting `Raw.Changes` produced by the reactions body into "proper" `Change`s, and proving that
the constraint properties of `Reaction` hold for the lifted reaction:

TODO: Fix code snippet below.

```lean
def Reaction.fromRaw (raw : Raw.Reaction ι υ) (h : False) : Reaction ι υ := {
  deps := raw.deps,
  triggers := raw.triggers,
  children := raw.children,
  body := (λ p s => (raw.body p s).attach.map (λ c => Change.fromRaw rtr.wf h c.property)),
  tsSubInDeps := ...,
  outDepOnly := ...,
  normNoChild := ...
}
```

The notion of raw-equivalence for reactions is again almost trivial, except for `body`:

```lean
structure Reaction.rawEquiv (rcn : Reaction ι υ) (raw : Raw.Reaction ι υ) : Prop :=
  deps :     rcn.deps = raw.deps
  triggers : rcn.triggers = raw.triggers
  children : rcn.children = raw.children
  body :     ∀ p s, List.forall₂ Change.rawEquiv (rcn.body p s) (raw.body p s)
```

The `body` property states that on equal inputs `p` and `s`, the "proper" `rcn` and `raw` reaction both have to produce the "same"
outputs, in the sense that the produced changes all have to be raw-equivalent and in the same order (cf. `List.forall₂`).

### Relay Reactions

Relay reactions are a specific kind of reaction that allow us to simplify what it means for reactors' ports to be connected.
In the semi-formal definition of the Reactor model we say that reactors can contain nested reactors where the output ports of
a nested reactor can have a "connection" to an input port of another nested reactor.

This explicit notion of a "connection" can be removed by exploiting the way in which reactions can interact with nested reactors:
A reaction can declare as dependency an input port of its container or *an output port of a nested reactor* of its container.
Analogously, a reaction can declare as antidependency an output port of its container or *an input port of a nested reactor* of its container.
Thus, we can formalize connections between reactors' ports by creating a reaction that declares these ports and only these ports as dependency
and antidependency respectively, and does nothing but relay the value from its input to its output.

Therefore, we call such a reaction a relay reaction:

```lean
def Reaction.relay (src dst : ι) : Reaction ι υ := {
  deps := λ r => match r with | Role.in => Finset.singleton src | Role.out => Finset.singleton dst,
  triggers := Finset.singleton src,
  children := ∅,
  body := λ p _ => match p[src] with | none => [] | some v => [Change.port dst v],
  tsSubInDeps := ...,
  outDepOnly := ...,
  normNoChild := ...
}
```

In order to behave exactly as desired, relay reactions also require some special treatment within reactors.

## `Reactor`

